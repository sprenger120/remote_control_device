### Code overview

<pre>
├── base
├── canfestival
├── hippomocks
├── objectDictionary
│   ├── generatedOD
│   └── RemoteControlDevice.od
├── remote_control_device.cubemx
├── src
│   ├── CanFestival
│   ├── PeripheralDrivers
│   ├── Statemachine
│   ├── *
</pre>

- base: Makefile build engine, C++ embedded bindings, git information retrieval
- canfestival: CANopen stack and tests
- hippomocks: Mocking library for CanFestival and firmware
- objectDictionary: CanFestival objgenedit file, generated .c / .h files
- remote_control_device.cubemx: Chip initialisation / HAL code generated by STM32 CubeMX
- src/CanFestival: Support code to make CanFestival usable with modern C++ / RTOS
- src/PeripheralDrivers: RTOS Tasks handling CAN and UARTs
- src/Statemachine: 'Brain' of the application. Binds all parts of the application together
- src/* : Support code / separated out code for better testing 

**See [Structure.pdf](firmware/doc/structure.pdf) for internal data flow.**

### Why a realtime operating system is necessary

For project where you are only doing one thing an RTOS is overkill and a superloop is sufficient.
But as soon as you have to juggle more data sources and calculations / tranmissions have to be done 
one time its hard to justify not using one. An RTOS makes it easy to keep hard realtime constraints with
low jitter as you are encouraged to keep interrupt code short and instead deferr proecessing to a task
which in turn can process when constraints allow it. 


### Application bootup 

1. The chip resets on powerup and begins executing the startup assembly code (remote_control_device.cubemx/startup_stm32f302x8.s) which sets up the interrupt vectors and copies variable's initialisation data into ram.

2. remote_control_device.cubemx/Core/Src/main.c main() is executed which initializes clocks and peripherals, creates tasks (remote_control_device.cubemx/Core/Src/freertos.c) and starts the FreeRTOS scheduler which immediately takes control of the execution flow executing tasks that are in the ready state always preferring higher priority tasks. 

3. The system tick interrupt runs every millisecond (configured in remote_control_device.cubemx/Core/Inc/FreeRTOSConfig.h) allowing the scheduler to interrupt the currently running thread to schedule another one.


### Tasks

Every task has more in depht explaination in their header file. 

- FreeRTOS' Timer Task: runs src/LEDs code at specified intervals depending on the blinking mode
- CanFestivalTimers: src/CanFestival/CanFestivalTimers Executes timers registered by CanFestival 
- ReceiverModule: src/PeripheralDrivers/ReceiverModule Starts / waits for reception of data from FrSky XM+ receiver module. Also decodes data upon arrival.
- CanIO: src/PeripheralDrivers/CanIO handles can peripherals TX / RX mailboxes. Adds send / dispatch hooks for CanFestival communication.
- TerminalIO: src/PeripheralDrivers/TerminalIO debug console, handles UART reception / transmission
- Statemachine: src/Statemachine/Statemachine checks 'StateChangingSources' and switches internal state depending on it. Handles in state operations such as preparing remote control inputs for CanFestival

### General task structure

You can differentiate between "Hardware" and "Software" handling tasks. 

- a Hardware-handling tasks is blocked most of the time waiting for the processor to call an interrupt service routine (ISR) which is bound to a callback within the class. This callback then uses FreeRTOS Notify functions to signal the event, the task is then unblocked.

- a Software-handling task will be executed periodically and employs FreeRTOS vTaskDelay function. 

All tasks are designed to be semi-singletons. Due to testing requirements there had to be some hacking in order to test these things properly.


### Statemachine

The complete behavior of a state is within a Statemachine::State instance. All states are contained in the big Statemachine::_states array. See Statemachine::State doxygen comment about capabilities attributes. Every state requires a priority to retain order when more than one states are available for switching to.  


### Canopen

Interface between the statemachine and CanFestival. The separation is necessary to keep the code readable and testable. Canopen can be tested by itself and statemachine can get a mock of canopen for validation. 

